<!DOCTYPE html>
<html lang="es">
<head>
<!-- Highlight.js estilo -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gráficas Python</title>
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      margin: 2em;
      padding-top: 70px;
      background-color: #f9f9f9;
      color: #222;
      line-height: 1.6;
    }
    .barra-logo {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: var(--Guinda-GOB-MX, #611232);
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      z-index: 100;
    }
    .barra-logo img {
      height: 44px;
      max-height: 100%;
      display: block;
    }

    .container {
      max-width: 960px;
      margin: auto;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    .flex-container {
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      justify-content: flex-start;
    }

    .svg-container img {
      width: 100%;
      max-width: 100%;
      height: auto;
      max-height: 200px; /* o el valor que ya tienes */
      object-fit: contain;
      margin-bottom: 1rem;
      display: block;
    }

    h1 {
      font-size: 28px;
      text-align: center;
      margin-bottom: 0.5rem;
      color: #222;
    }
    p {
      text-align: center;
      margin-bottom: 1rem;
      color: #444;
    }
    .code-card {
      width: 1000px;
      min-width: 320px;
      max-width: 100%;
      height: 400px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: stretch;
      background: #fff;
      border: 1px solid #DDD;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      padding: 16px;
      margin-bottom: 2rem;
      overflow: hidden;
    }
    .code-header {
      position: sticky;
      top: 0;
      background: white;
      padding-bottom: 10px;
      margin-bottom: 10px;
      border-bottom: 1px solid #EEE;
      font-weight: 600;
      font-size: 16px;
    }
    .code-content {
      flex: 1 1 auto;
      overflow-y: auto;
      max-height: 350px;
      background: #fdfdfd;
      border-radius: 0.5rem;
      padding: 1rem;
    }
    .btn {
      display: inline-block;
      align-self: center;
      background-color: #671335;
      color: white;
      padding: 0.6rem 1.2rem;
      text-decoration: none;
      border-radius: 0.25rem;
      text-align: center;
      margin-top: 1rem;
    }
    .btn:hover {
      background-color: #4a0e25;
    }
    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }
      .code-content {
        max-height: 300px;
      }
    }
    .menu-dropdown-wrapper {
    position: relative;
    margin-left: auto;   /* <-- Esto lo empuja a la derecha */
    display: flex;
    align-items: center;
    padding-right: 30px;
    }
    .menu-toggle {
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    margin: 0;
    }
    .menu-dropdown {
    position: absolute;
    top: 60px;
    right: 0;
    display: none;
    flex-direction: column;
    padding: 16px 8px;
    gap: 8px;
    background: #FFF;
    border-radius: 4px;
    box-shadow: 0px 2.75px 9px 0px rgba(109, 109, 109, 0.19);
    z-index: 1000;
    min-width: 160px;
    }
    .menu-dropdown a {
    text-decoration: none;
    color: #333;
    font-weight: 400;
    font-size: 14px;
    padding: 4px 0;
    }
    .menu-dropdown a:hover {
    font-weight: 500;
    color: #611232;
    }
  </style>
</head>
<body>
  <header class="barra-logo">
    <img src="imagenes/logo_gob.svg" class="logo-izquierdo" alt="Logo del gobierno">
    <div class="menu-dropdown-wrapper">
        <button class="menu-toggle">
            <img src="imagenes/Menu.svg" alt="Menu" width="30" height="30">
        </button>
        <div class="menu-dropdown" id="menuDropdown">
            <a href="index.html">Inicio</a>
            <a href="graficas-python.html">Python</a>
            <a href="graficas-r.html">RStudio</a>
    </div>
  </div>
</header>

  <div class="container">
    <h1>Gráficas Python</h1>
    <p>Copia y pega el siguiente código en tu proyecto de Python para generar una gráfica SVG con estilo personalizado.</p>
<div class="flex-container">
    <div class="code-card">
      <div class="code-header">Gráfica de barras agrupadas y apiladas</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/agrupadasyapiladas/grafica_agrupadasyapiladas.svg" alt="Ejemplo gráfico agrupadas y apiladas">
      </div>
    <pre><code class="language-python">
# Configurar las fuentes SVG como texto editable
plt.rcParams['svg.fonttype'] = 'none'

# Ruta relativa para las fuentes
font_dirs = [Path("fonts/arial")]
font_files = font_manager.findSystemFonts(fontpaths=font_dirs)

for font_file in font_files:
    font_manager.fontManager.addfont(font_file)

# Crear una instancia de FontProperties para Arial
arial_font = font_manager.FontProperties(fname=str(font_files[0]))

def agrupadasyapiladas(dataframes):
    """
    Genera una gráfica de barras apiladas agrupadas para múltiples DataFrames.
    Args:
        dataframes (list of pd.DataFrame): Lista de DataFrames con los datos de los grupos de subgrupos apilados.
    """
    font_config = {
        'family': 'Arial',
        'titulo': {'size': 36, 'weight': 'medium', 'color': '#000000'},
        'eje_y': {'size': 18, 'weight': 'medium', 'color': '#000000'},
        'eje_x': {'size': 18, 'weight': 'medium', 'color': '#000000'},
        'etiquetas_eje_y': {'size': 24, 'weight': 'medium', 'color': '#767676'},
        'etiquetas_eje_x': {'size': 24, 'weight': 'semibold', 'color': '#767676'},
        'capsula_valor': {'size': 9, 'weight': 'medium', 'color': '#10302C'},
        'capsula_max': {'size': 12, 'weight': 'medium', 'color': 'white'},
        'porcentaje': {'size': 10, 'weight': 'medium', 'color': '#4C6A67'},
        'leyenda': {'size': 14, 'weight': 'medium', 'color': '#767676'}
    }

    # Configuración de los grupos y subgrupos
    grupos = dataframes[0].index.tolist()
    subgrupos_list = [df.columns.tolist() for df in dataframes]

    # Obtener colores desde la función colores()
    lista_colores = ["#006157", "#767676", "#671435", "#9B2247", "#9D792A", "#D5B162", "#10302C", "#E6D194", "#018477", "#FF6666", "#00008B", "#854991"]
    colores_por_grupo = []
    color_index = 0
    for subgrupos in subgrupos_list:
        colores_por_grupo.append(lista_colores[color_index:color_index + len(subgrupos)])
        color_index += len(subgrupos)

    # Configuración visual
    factor_ancho = 0.4
    ancho_total = len(grupos) * factor_ancho
    max_subgrupos = max(len(df.columns) for df in dataframes)
    ancho_barra = ancho_total / (len(dataframes) * max_subgrupos)
    desplazamiento = -ancho_total / 2 + ancho_barra / 2

    # Configurar el tamaño de la figura en píxeles
    ancho_px = 1480
    alto_px = 520
    dpi = 100
    ancho_in = ancho_px / dpi
    alto_in = alto_px / dpi

    fig, ax = plt.subplots(figsize=(ancho_in, alto_in), dpi=dpi)
    x_pos = np.arange(len(grupos))

    for df, colores, offset in zip(dataframes, colores_por_grupo, range(len(dataframes))):
        bottom = np.zeros(len(grupos))
        total_grupo = df.sum(axis=1)
        for subgrupo, color in zip(df.columns, colores):
            valores = df[subgrupo]
            ax.bar(
                x_pos + desplazamiento,
                valores,
                width=ancho_barra,
                bottom=bottom,
                color=color,
                label=subgrupo,
            )
            for i, valor in enumerate(valores):
                porcentaje = (valor / total_grupo.iloc[i]) * 100 if total_grupo.iloc[i] != 0 else 0
                ax.text(
                    x_pos[i] + desplazamiento,
                    bottom[i] + valor / 2,
                    f"{int(valor):,} ({porcentaje:.1f}%)",
                    ha='center',
                    va='center',
                    fontsize=font_config['capsula_valor']['size'],
                    fontweight=font_config['capsula_valor']['weight'],
                    color='white' if porcentaje > 10 else 'black'
                )
            bottom += np.array(valores)

        factor_separacion = max(bottom) * 0.05
        for i, total in enumerate(bottom):
            ax.text(
                x_pos[i] + desplazamiento,
                total + factor_separacion,
                f"{int(total):,}",
                ha="center",
                va="bottom",
                fontsize=font_config['capsula_max']['size'],
                fontweight=font_config['capsula_max']['weight'],
                color=colores[1] if len(colores) > 1 else 'black',
                bbox=dict(boxstyle="round,pad=0.35,rounding_size=0.99", fc="white", ec=colores[0], alpha=1.0)
            )

        desplazamiento += ancho_barra

    ax.legend(
        loc='upper center',
        bbox_to_anchor=(0.5, 1.5),
        frameon=False,
        prop={'size': font_config['leyenda']['size'], 'weight': font_config['leyenda']['weight']},
        ncol=max(1, len(dataframes)),
    )

    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['bottom'].set_visible(True)
    ax.spines['bottom'].set_linewidth(2)
    ax.grid(axis='y', linestyle='-', color='#000000', alpha=0.2, linewidth=0.75)
    ax.yaxis.set_major_formatter(mticker.FuncFormatter(lambda x, _: f"{int(x):,}"))
    ax.tick_params(axis='y', labelsize=font_config['eje_y']['size'], labelcolor=font_config['eje_y']['color'])
    ax.yaxis.label.set_size(font_config['eje_y']['size'])
    ax.yaxis.label.set_weight(font_config['eje_y']['weight'])
    ax.yaxis.label.set_color(font_config['eje_y']['color'])
    ax.set_xticks(x_pos)
    ax.set_xticklabels(grupos, fontsize=font_config['eje_x']['size'], fontweight=font_config['eje_x']['weight'], color=font_config['eje_x']['color'])
    ax.set_ylabel('Valores', fontsize=font_config['etiquetas_eje_y']['size'], fontweight=font_config['etiquetas_eje_y']['weight'], color=font_config['etiquetas_eje_y']['color'])
    plt.tight_layout()
    plt.savefig("grafica_agrupadasyapiladas.svg", format="svg", bbox_inches='tight', dpi=dpi)
    plt.show()

# Llamar a la función con una lista de DataFrames
agrupadasyapiladas(dataframes_a_graficar)
</code></pre>
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/agrupadasyapiladas" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
 </div>
<div class="flex-container">
    <div class="code-card">
      <div class="code-header">Areaplot</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/areaplot/areaplot.svg" alt="Ejemplo gráfico areaplot">
      </div>
<pre><code class="language-python">
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import font_manager
from scipy.interpolate import make_interp_spline

# VARIABLES A CAMBIAR:
dataframe_a_graficar = data

# Configurar las fuentes SVG como texto editable
plt.rcParams['svg.fonttype'] = 'none'

# Ruta relativa para las fuentes
font_dirs = [Path("fonts/arial")]
font_files = font_manager.findSystemFonts(fontpaths=font_dirs)

for font_file in font_files:
    font_manager.fontManager.addfont(font_file)

# Crear una instancia de FontProperties para Arial
arial_font = font_manager.FontProperties(fname=str(font_files[0]))

def areaplot(data):
    """
    Genera un gráfico de área apilada con los datos proporcionados en un DataFrame.
    Parámetros:
    - data: DataFrame que contiene las columnas 'fechas', 'comisiones', 'fiscalias' y 'portal'.
    """
    font_config = {
        'family': 'Arial',
        'titulo': {'size': 16, 'weight': 'bold', 'color': '#10302C'},
        'eje_y': {'size': 24, 'weight': 'medium', 'color': '#767676'},
        'eje_x': {'size': 24, 'weight': 'semibold', 'color': '#767676'},
        'capsula_valor': {'size': 20, 'weight': 'medium', 'color': '#10302C'},
        'capsula_max': {'size': 12, 'weight': 'medium', 'color': 'white'},
        'porcentaje': {'size': 10, 'weight': 'medium', 'color': '#4C6A67'},
        'leyenda': {'size': 20, 'weight': 'medium', 'color': '#767676'}
    }

    # Extraer columnas del DataFrame
    fechas = data['fechas']
    comisiones = data['comisiones']
    fiscalias = data['fiscalias']
    portal = data['portal']
    
    # Crear figura
    fig, ax = plt.subplots(figsize=(16, 8))
    n = len(fechas)
    x = np.arange(n) + 0.5

    # Suavizar las curvas visualmente
    x_suave = np.linspace(x.min(), x.max(), 300)
    comisiones_suave = make_interp_spline(x, comisiones)(x_suave)
    fiscalias_suave = make_interp_spline(x, fiscalias)(x_suave)
    portal_suave = make_interp_spline(x, portal)(x_suave)

    # Área apilada
    ax.stackplot(x_suave, comisiones_suave, fiscalias_suave, portal_suave, labels=[
                 'Comisiones', 'Fiscalías y Procuradurías', 'Portal'],
                 colors=['#215F53', '#7570B3', '#C7EAE5'])

    # Eje X
    ax.set_xticks(x)
    ax.set_xticklabels(fechas, rotation=90, fontsize=font_config['eje_x']['size'],
                        fontweight=font_config['eje_x']['weight'], color=font_config['eje_x']['color'])    
    ax.set_xlim(x[0] - 0.5, x[-1] + 0.5)

    # Eje Y
    ax.set_yticks(np.linspace(0, 1, 5))
    ax.set_yticklabels(['0%', '25%', '50%', '75%', '100%'], fontsize=font_config['eje_y']['size'],
                        fontweight=font_config['eje_y']['weight'], color=font_config['eje_y']['color'])    
    ax.set_ylabel('Porcentaje', fontsize=font_config['eje_y']['size'],
                  fontweight=font_config['eje_y']['weight'], color=font_config['eje_y']['color'])    

    # Bordes y grid
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['bottom'].set_visible(True)
    ax.spines['bottom'].set_linewidth(2)
    ax.grid(axis='y', linestyle='-', color='white', alpha=0.8, linewidth=1.25)
    ax.grid(axis='x', linestyle='-', color='white', alpha=0.3, linewidth=0.75)

    # Coordenadas y valores totales por capa
    x_coords = [2, 8, 14]
    y_coords = [0.15, 0.45, 0.85]
    totales = [round(sum(comisiones), 2), round(sum(fiscalias), 2), round(sum(portal), 2)]
    colores_borde = ['#D9D9D9'] * 3

    for x, y, total, color_borde in zip(x_coords, y_coords, totales, colores_borde):
        ax.text(
            x, y, f"{total:,}",
            ha='center', va='center',
            fontsize=font_config['capsula_valor']['size'],
            fontweight=font_config['capsula_valor']['weight'],
            color=font_config['capsula_valor']['color'],
            bbox=dict(
                boxstyle="round,pad=0.6,rounding_size=0.99",
                facecolor='white',
                edgecolor=color_borde,
                linewidth=1.8
            )
        )

    # Leyenda centrada arriba con tamaño ajustado
    ax.legend(
        loc='upper center',
        bbox_to_anchor=(0.5, 1.12),
        ncol=3,
        frameon=False,
        prop=font_manager.FontProperties(
            size=font_config['leyenda']['size'], 
            weight=font_config['leyenda']['weight']
        )
    )

    plt.tight_layout()
    plt.savefig("areaplot.svg", format="svg", bbox_inches='tight')
    plt.show()

areaplot(dataframe_a_graficar)
</code></pre>
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/areaplot" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
</div>
<div class="flex-container">
    <div class="code-card">
      <div class="code-header">Areaplot 2</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/areaplot2/areaplot2.svg" alt="Ejemplo gráfico areaplot">
    </div>
<pre><code class="language-python">
from pathlib import Path
import matplotlib.pyplot as plt
import matplotlib.font_manager as font_manager
import matplotlib.ticker as mticker
from adjustText import adjust_text

# VARIABLES A CAMBIAR
dataframe_a_graficar = df
columna_eje_x = "Fecha"

# Configurar las fuentes SVG como texto editable
plt.rcParams['svg.fonttype'] = 'none'

# Ruta relativa para las fuentes
font_dirs = [Path("fonts/arial")]
font_files = font_manager.findSystemFonts(fontpaths=font_dirs)

for font_file in font_files:
    font_manager.fontManager.addfont(font_file)

# Crear una instancia de FontProperties para Arial
arial_font = font_manager.FontProperties(fname=str(font_files[0]))


def ajusta_etiquetas_apiladas_manual(dataframe, columnas, colores, columna_x, sin_tag=1, etiquetar_max=True, bbox_props=None, fontsize=12, separacion=40):
    """
    Ajusta las etiquetas de los puntos en una gráfica apilada, colocándolas por encima del punto más alto
    y apilándolas verticalmente en orden correcto.

    Args:
        dataframe (pd.DataFrame): DataFrame con los datos.
        columnas (list): Columnas a etiquetar.
        colores (list): Colores para cada etiqueta.
        columna_x (str): Columna para el eje X.
        sin_tag (int): Puntos sin etiqueta entre etiquetas. Default: 2.
        etiquetar_max (bool): Si True, etiqueta el valor máximo de cada columna. Default: True.
        bbox_props (dict): Propiedades del fondo de la etiqueta. Default: None (estilo predeterminado).
        fontsize (int): Tamaño de fuente. Default: 12.
        separacion (int): Separación vertical entre etiquetas (en unidades Y). Default: 40.
    """
    # Calcular la altura acumulada máxima en cada punto X
    acumulado = dataframe[columnas].cumsum(axis=1)
    y_max_global = acumulado.max(axis=1)  # Altura máxima en cada X

    # Diccionario para guardar la posición Y más alta ocupada en cada X
    y_max_por_x = {}

    colores = ["#006157", "#767676", "#671435", "#9B2247", "#9D792A", "#D5B162"]

    for col, color in zip(columnas, colores):
        total_puntos = len(dataframe)
        max_index = dataframe[col].idxmax() if etiquetar_max else None  # Índice del máximo si etiquetar_max=True

        for i, row in dataframe.iterrows():
            x_pos = row[columna_x]  # Posición X actual
            tiene_etiqueta = (
                (total_puntos - i - 1) % (sin_tag + 1) == 0  # Cada 'sin_tag' puntos
                or i == total_puntos - 1  # Siempre etiquetar el último punto
                or (etiquetar_max and i == max_index)  # Etiquetar el máximo si etiquetar_max=True
            )

            if tiene_etiqueta:
                # Altura base: el punto más alto en esta posición X
                y_base = y_max_global[i] - 200  # Desplazar todas las etiquetas hacia abajo (ajusta el valor -200 según sea necesario)
                # Si ya hay una etiqueta en esta X, apilarla encima de la última
                if x_pos in y_max_por_x:
                    y_etiqueta = y_max_por_x[x_pos] + separacion
                else:
                    y_etiqueta = y_base + separacion  # Espacio inicial por encima del punto más alto

                # Actualizar la altura máxima registrada para esta X
                y_max_por_x[x_pos] = y_etiqueta

                # Configurar el fondo de la etiqueta para puntos intermedios
                if i != 1 and i != total_puntos - 1:  # Puntos intermedios
                    bbox_props_intermedio = dict(boxstyle="round,pad=0.3,rounding_size=0.99", fc="white", ec="gray", alpha=1.0)
                    texto_color = color  # Mismo color que la gráfica
                else:  # Puntos máximos o finales
                    bbox_props_intermedio = bbox_props or dict(boxstyle="round,pad=0.3,rounding_size=0.99", fc=color, ec="none", alpha=1.0)
                    texto_color = "white"  # Texto blanco para máximos/finales

                # Añadir la etiqueta
                plt.text(
                    x_pos,          # Posición X (misma que la barra)
                    y_etiqueta,      # Posición Y (encima del punto más alto/apilada)
                    f"{int(row[col]):,}",
                    fontsize=fontsize,
                    color=texto_color,  # Color del texto
                    ha='center',
                    va='bottom',
                    bbox=bbox_props_intermedio
                )

def areaplot2(df, columna_fecha, tipografia=None):
    """
    Genera una gráfica de área (area plot) a partir de un DataFrame.

    Args:
        df (pd.DataFrame): DataFrame que contiene los datos a graficar.
        columna_fecha (str): Nombre de la columna que se usará como eje X.
        tipografia (FontProperties, optional): Fuente personalizada para los textos. Por defecto es None.
    """
    font_config = {
        'family': 'Arial',  # Cambiar a Arial
        'titulo': {'size': 36, 'weight': 'medium', 'color': '#000000'},
        'eje_y': {'size': 24, 'weight': 'medium', 'color': '#000000'},
        'eje_x': {'size': 24, 'weight': 'medium', 'color': '#000000'},
        'etiquetas_eje_y': {'size': 24, 'weight': 'medium', 'color': '#767676'},
        'etiquetas_eje_x': {'size': 24, 'weight': 'semibold', 'color': '#767676'},
        'capsula_valor': {'size': 9, 'weight': 'medium', 'color': '#10302C'},
        'capsula_max': {'size': 12, 'weight': 'medium', 'color': 'white'},
        'porcentaje': {'size': 10, 'weight': 'medium', 'color': '#4C6A67'},
        'leyenda': {'size': 20, 'weight': 'medium', 'color': '#767676'}  # Nueva categoría para la leyenda
    }
    
    # Verificar que la columna especificada exista en el DataFrame
    if columna_fecha not in df.columns:
        raise ValueError(f"La columna '{columna_fecha}' no existe en el DataFrame.")
    
    # Configurar el tamaño de la figura en píxeles
    ancho_px = 1480
    alto_px = 520
    dpi = 100  # Resolución en píxeles por pulgada
    ancho_in = ancho_px / dpi
    alto_in = alto_px / dpi
    
    # Crear la figura con el tamaño especificado
    fig, ax = plt.subplots(figsize=(ancho_in, alto_in), dpi=dpi)
    
    # Obtener los colores
    colores_asignados = ["#006157", "#767676", "#671435", "#9B2247", "#9D792A", "#D5B162"]
    
    # Obtener las columnas a graficar (excluyendo la columna de fecha)
    columnas_a_graficar = [col for col in df.columns if col != columna_fecha]
    
    # Graficar el área para cada columna
    ax.stackplot(
        df[columna_fecha],
        [df[col] for col in columnas_a_graficar],
        labels=columnas_a_graficar,
        colors=colores_asignados[:len(columnas_a_graficar)],
        alpha=0.8
    )

    # Configurar etiquetas y título
    ax.set_xlabel(columna_fecha, fontdict=font_config['etiquetas_eje_x'])
    ax.set_ylabel("Valores", fontdict=font_config['etiquetas_eje_y'])

    # Configurar las etiquetas del eje X
    ax.tick_params(axis='x', labelsize=font_config['etiquetas_eje_x']['size'], labelcolor=font_config['etiquetas_eje_x']['color'])
    ax.tick_params(axis='y', labelsize=font_config['etiquetas_eje_y']['size'], labelcolor=font_config['etiquetas_eje_y']['color'])

    # Posicionar el eje X en y=0
    ax.spines['bottom'].set_position(('data', 0))

    # Rotar las etiquetas del eje X
    plt.xticks(rotation=90)
    
    # Desactivar o activar bordes
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['bottom'].set_visible(True)
    
    # Asignar grosor a los ejes visibles
    ax.spines['bottom'].set_linewidth(2)  # Grosor del eje inferior
    
    # Mantener las líneas del grid
    ax.grid(axis='y', linestyle='-', color='#000000', alpha=0.2, linewidth=0.75)
    ax.grid(axis='x', linestyle='-', color='#000000', alpha=0.2, linewidth=0.75)

    # Ajustar etiquetas en los puntos máximos de cada columna
    ajusta_etiquetas_apiladas_manual(
        dataframe=df,
        columnas=columnas_a_graficar,
        colores=colores_asignados,
        columna_x=columna_fecha,
        fontsize=font_config['capsula_valor']['size'],
        separacion=1100
    )

    # Calcular el valor máximo de las etiquetas y agregar un margen
    y_max = df[columnas_a_graficar].sum(axis=1).max()  # Suma acumulada máxima
    margen = y_max * 0.5  # Margen del 10%
    ax.set_ylim(0, y_max + margen)  # Ajustar el límite del eje Y

    # Guardar la gráfica como archivo SVG
    #plt.savefig("areaplot2.png", format="png", bbox_inches='tight', dpi=dpi)
    plt.savefig("areaplot2.svg", format="svg", bbox_inches='tight', dpi=dpi)

# Llamar a la función con el DataFrame df, la columna 'Fecha' y la fuente personalizada
areaplot2(dataframe_a_graficar, columna_fecha=columna_eje_x, tipografia=arial_font) 
</code></pre>
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/areaplot2" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
</div>

<div class="flex-container">
    <div class="code-card">
      <div class="code-header">Barras apiladas horizontales</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/barras apiladas horizontales/barras_apiladas_horizontales.svg" alt="Ejemplo gráfico areaplot">
    </div>
<pre><code class="language-python">
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import font_manager

# VARIABLES A CAMBIAR:
dataframe_a_graficar = data

# Configurar las fuentes SVG como texto editable
plt.rcParams['svg.fonttype'] = 'none'

# Ruta relativa para las fuentes
font_dirs = [Path("fonts/arial")]
font_files = font_manager.findSystemFonts(fontpaths=font_dirs)

for font_file in font_files:
    font_manager.fontManager.addfont(font_file)

# Crear una instancia de FontProperties para Arial
arial_font = font_manager.FontProperties(fname=str(font_files[0]))


def calcular_intervalo(max_valor):
    """Calcula un intervalo adecuado para el eje Y basado en el valor máximo"""
    potencia = 10 ** (int(np.log10(max_valor)) - 1)
    intervalo = round(max_valor / 5 / potencia) * potencia

    # Asegurar que el intervalo no sea muy pequeño o grande
    if max_valor / intervalo > 8:
        intervalo *= 2
    elif max_valor / intervalo < 4:
        intervalo /= 2

    return max(intervalo, 1)  # Mínimo intervalo de 1

def barras_apiladas_horizontales(data_vertical, bar_width=0.6):
    font_config = {
        'family': 'Arial',  # Cambiar a Arial
        'titulo': {'size': 36, 'weight': 'medium', 'color': '#000000'},
        'eje_y': {'size': 18, 'weight': 'medium', 'color': '#000000'},
        'eje_x': {'size': 18, 'weight': 'medium', 'color': '#000000'},
        'etiquetas_eje_y': {'size': 24, 'weight': 'medium', 'color': '#767676'},
        'etiquetas_eje_x': {'size': 24, 'weight': 'semibold', 'color': '#767676'},
        'capsula_valor': {'size': 12, 'weight': 'medium', 'color': '#10302C'},
        'capsula_max': {'size': 32, 'weight': 'medium', 'color': 'white'},
        'porcentaje': {'size': 14, 'weight': 'medium', 'color': '#4C6A67'},
        'leyenda': {'size': 20, 'weight': 'medium', 'color': '#767676'}  # Nueva categoría para la leyenda
    }

    categorias = ['Hombre', 'Mujer', 'No identificado']
    data['Total'] = data[categorias].sum(axis=1)
    sorted_data = data.sort_values(by='Total', ascending=False)
    entidades = sorted_data.index.tolist()

    max_valor = sorted_data['Total'].max()
    total = sorted_data['Total'].sum()
    x_max = max_valor * 1.15
    x_interval = max_valor // 5 or 1

    fig, ax = plt.subplots(figsize=(10, 14), dpi=300)
    fig.patch.set_facecolor('white')
    ax.set_facecolor('white')

    x_ticks = np.arange(0, x_max + x_interval, x_interval)
    for x in x_ticks:
        lw = 2 if x == max_valor else 0.75
        lc = 'black' if x == max_valor else '#B9B9B9'
        ax.axvline(x, color=lc, linewidth=lw)

    ax.axvline(0, color='black', linewidth=2, zorder=1)

    offset_capsula = x_max * 0.015
    offset_porcentaje = x_max * 0.09
    bar_positions = np.arange(len(entidades))

    colores = {
        'Hombre': '#4C6A67',
        'Mujer': '#627B78',
        'No identificado': '#6F8583'
    }
    categorias = list(colores.keys());

    for i, entidad in enumerate(entidades):
        row = sorted_data.loc[entidad]
        y_pos = bar_positions[i]
        x_left = 0

        for cat in categorias:
            valor = row[cat]
            ax.barh(y_pos, valor, height=bar_width, left=x_left,
                    color=colores[cat], edgecolor='none', zorder=2)
            x_left += valor

        total_valor = row['Total']
        porcentaje = round((total_valor / total) * 100, 1)

        texto_kwargs = dict(
            ha='left',
            va='center',
            fontsize=font_config['capsula_valor']['size'],
            fontfamily=font_config['family'],
            fontweight=font_config['capsula_valor']['weight'],
            color=font_config['capsula_valor']['color']
        )

        if total_valor <= 5:
            boxstyle = "round,pad=0.4,rounding_size=0.59"
        elif total_valor <= 50:
            boxstyle = "round,pad=0.3,rounding_size=0.7"
        elif total_valor <= 100:
            boxstyle = "round,pad=0.3,rounding_size=0.79"
        else:
            boxstyle = "round,pad=0.3,rounding_size=0.9"

        bbox_props = dict(
            boxstyle=boxstyle,
            facecolor='white',
            edgecolor='#002F2A',
            linewidth=1.5
        )

        ax.text(
            total_valor + offset_capsula, y_pos, f"{int(total_valor):,}",
            bbox=bbox_props,
            **texto_kwargs
        )

        ax.text(
            total_valor + offset_porcentaje, y_pos, f"{porcentaje}%",
            color=font_config['porcentaje']['color'],
            fontsize=font_config['porcentaje']['size'],
            fontfamily=font_config['family'],
            fontweight=font_config['porcentaje']['weight'],
            ha='left',
            va='center'
        )

    ax.set_yticks(bar_positions)
    ax.set_yticklabels(
        entidades,
        fontsize=font_config['eje_y']['size'],
        fontfamily=font_config['family'],
        fontweight=font_config['eje_y']['weight']
    )

    ax.set_xlim(0, x_max)
    ax.invert_yaxis()

    for spine in ax.spines.values():
        spine.set_visible(False)
    ax.tick_params(
        axis='x',
        labelsize=font_config['eje_x']['size'],  # Tamaño de la fuente
        labelcolor=font_config['eje_x']['color']  # Color de la fuente
    )
    ax.grid(False)

    plt.tight_layout()

    # Guardar la gráfica como archivo SVG
    plt.savefig("barras_apiladas_horizontales.svg", format="svg", bbox_inches='tight')
    plt.show()

barras_apiladas_horizontales(dataframe_a_graficar)
</code></pre>
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/barras%20apiladas%20horizontales" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
</div>

 <div class="flex-container">
    <div class="code-card">
      <div class="code-header">Barras apiladas verticales</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/barras apiladas verticales/barras_apiladas_verticales.svg">
    </div>
<pre><code class="language-python">
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import font_manager

# VARIABLES A CAMBIAR:
dataframe_a_graficar = data

# Configurar las fuentes SVG como texto editable
plt.rcParams['svg.fonttype'] = 'none'

# Ruta relativa para las fuentes
font_dirs = [Path("fonts/arial")]
font_files = font_manager.findSystemFonts(fontpaths=font_dirs)

for font_file in font_files:
    font_manager.fontManager.addfont(font_file)

# Crear una instancia de FontProperties para Arial
arial_font = font_manager.FontProperties(fname=str(font_files[0]))


def calcular_intervalo(max_valor):
    """Calcula un intervalo adecuado para el eje Y basado en el valor máximo"""
    potencia = 10 ** (int(np.log10(max_valor)) - 1)
    intervalo = round(max_valor / 5 / potencia) * potencia

    # Asegurar que el intervalo no sea muy pequeño o grande
    if max_valor / intervalo > 8:
        intervalo *= 2
    elif max_valor / intervalo < 4:
        intervalo /= 2

    return max(intervalo, 1)  # Mínimo intervalo de 1

def barras_apiladas_verticales(data, bar_width=0.6):
    font_config = {
        'family': 'Arial',  # Cambiar a Arial
        'titulo': {'size': 36, 'weight': 'medium', 'color': '#000000'},
        'eje_y': {'size': 18, 'weight': 'medium', 'color': '#000000'},
        'eje_x': {'size': 12, 'weight': 'medium', 'color': '#000000'},
        'etiquetas_eje_y': {'size': 24, 'weight': 'medium', 'color': '#767676'},
        'etiquetas_eje_x': {'size': 24, 'weight': 'semibold', 'color': '#767676'},
        'capsula_valor': {'size': 12, 'weight': 'medium', 'color': '#10302C'},
        'capsula_max': {'size': 32, 'weight': 'medium', 'color': 'white'},
        'porcentaje': {'size': 14, 'weight': 'medium', 'color': '#4C6A67'},
        'leyenda': {'size': 20, 'weight': 'medium', 'color': '#767676'}  # Nueva categoría para la leyenda
    }

    categorias = ['Hombre', 'Mujer', 'No identificado']
    data['Total'] = data[categorias].sum(axis=1)
    sorted_data = data.sort_values(by='Total', ascending=False)
    entidades = sorted_data.index.tolist()

    max_valor = sorted_data['Total'].max()
    total = sorted_data['Total'].sum()

    y_max = max_valor * 1.15
    y_interval = calcular_intervalo(max_valor)

    fig, ax = plt.subplots(figsize=(16, 6), dpi=300)
    fig.patch.set_facecolor('white')
    ax.set_facecolor('white')

    y_ticks = np.arange(0, y_max + y_interval, y_interval)
    for y in y_ticks:
        lw = 2 if y == y_max else 0.75
        lc = 'black' if y == y_max else '#B9B9B9'
        ax.axhline(y, color=lc, linewidth=lw)

    ax.axhline(0, color='black', linewidth=2, zorder=1)

    offset_capsula = y_max * 0.05  
    offset_porcentaje = y_max * 0.15 
    bar_positions = np.arange(len(entidades))

    colores = {
        'Hombre': '#4C6A67',
        'Mujer': '#627B78',
        'No identificado': '#6F8583'
    }
    categorias = list(colores.keys());

    for i, entidad in enumerate(entidades):
        row = sorted_data.loc[entidad]
        x_pos = bar_positions[i]
        y_bottom = 0

        for cat in categorias:
            valor = row[cat]
            ax.bar(x_pos, valor, width=bar_width, bottom=y_bottom,
                   color=colores[cat], edgecolor='none', zorder=2)
            y_bottom += valor

        total_valor = row['Total']
        porcentaje = round((total_valor / total) * 100, 1)

        # Estilo de texto
        texto_kwargs = dict(
            ha='center',
            va='bottom',
            fontsize=font_config['capsula_valor']['size'],
            fontfamily=font_config['family'],
            fontweight=font_config['capsula_valor']['weight'],
            color=font_config['capsula_valor']['color']
        )

        # Ajuste de estilo de cápsula según el valor
        if total_valor <= 5:
            boxstyle = "round,pad=0.4,rounding_size=0.59"
        elif total_valor <= 50:
            boxstyle = "round,pad=0.3,rounding_size=0.7"
        elif total_valor <= 100:
            boxstyle = "round,pad=0.3,rounding_size=0.79"
        else:
            boxstyle = "round,pad=0.3,rounding_size=0.9"

        bbox_props = dict(
            boxstyle=boxstyle,
            facecolor='white',
            edgecolor='#002F2A',
            linewidth=1.5
        )

        # Cápsula con total
        ax.text(
            x_pos, total_valor + offset_capsula, f"{int(total_valor):,}",
            bbox=bbox_props,
            **texto_kwargs
        )

        # Porcentaje encima
        ax.text(
            x_pos, total_valor + offset_porcentaje, f"{porcentaje}%",
            color=font_config['porcentaje']['color'],
            fontsize=font_config['porcentaje']['size'],
            fontfamily=font_config['family'],
            fontweight=font_config['porcentaje']['weight'],
            ha='center',
            va='bottom'
        )

    # Eje X
    ax.set_xticks(bar_positions)
    ax.set_xticklabels(
        entidades, rotation=90,
        fontsize=font_config['eje_x']['size'],
        fontfamily=font_config['family'],
        fontweight=font_config['eje_x']['weight']
    )

    ax.set_ylim(0, y_max)
    ax.set_xlim(bar_positions[0] - bar_width, bar_positions[-1] + bar_width)

    # Limpiar bordes y ticks
    for spine in ax.spines.values():
        spine.set_visible(False)
    ax.tick_params(axis='both', which='both', length=0)
    ax.grid(False)

    plt.tight_layout()

    # Guardar la gráfica como archivo SVG
    plt.savefig("barras_apiladas_verticales.svg", format="svg", bbox_inches='tight')
    plt.show()

barras_apiladas_verticales(dataframe_a_graficar)
</code></pre>
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/barras%20apiladas%20verticales" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
</div>

 <div class="flex-container">
    <div class="code-card">
      <div class="code-header">Barras horizontales</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/barras horizontales/barras_horizontales.svg">
    </div>
<pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import font_manager
from pathlib import Path

# VARIABLES A CAMBIAR:
dataframe_a_graficar = victimas_por_entidad

# Configurar las fuentes SVG como texto editable
plt.rcParams['svg.fonttype'] = 'none'

# Ruta relativa para las fuentes
font_dirs = [Path("fonts/arial")]
font_files = font_manager.findSystemFonts(fontpaths=font_dirs)

for font_file in font_files:
    font_manager.fontManager.addfont(font_file)

# Crear una instancia de FontProperties para Arial
arial_font = font_manager.FontProperties(fname=str(font_files[0]))


def calcular_intervalo(max_valor):
    """Calcula un intervalo adecuado para el eje Y basado en el valor máximo"""
    potencia = 10 ** (int(np.log10(max_valor)) - 1)
    intervalo = round(max_valor / 5 / potencia) * potencia

    # Asegurar que el intervalo no sea muy pequeño o grande
    if max_valor / intervalo > 8:
        intervalo *= 2
    elif max_valor / intervalo < 4:
        intervalo /= 2

    return max(intervalo, 1)  # Mínimo intervalo de 1

def barras_horizontales(victimas_por_entidad, bar_height=0.6):
    font_config = {
        'family': 'Arial',  # Cambiar a Arial
        'titulo': {'size': 36, 'weight': 'medium', 'color': '#000000'},
        'eje_y': {'size': 18, 'weight': 'medium', 'color': '#000000'},
        'eje_x': {'size': 18, 'weight': 'medium', 'color': '#000000'},
        'etiquetas_eje_y': {'size': 24, 'weight': 'medium', 'color': '#767676'},
        'etiquetas_eje_x': {'size': 24, 'weight': 'semibold', 'color': '#767676'},
        'capsula_valor': {'size': 12, 'weight': 'medium', 'color': '#10302C'},
        'capsula_max': {'size': 32, 'weight': 'medium', 'color': 'white'},
        'porcentaje': {'size': 14, 'weight': 'medium', 'color': '#4C6A67'},
        'leyenda': {'size': 20, 'weight': 'medium', 'color': '#767676'}  # Nueva categoría para la leyenda
    }

    # Ordenar de mayor a menor 
    sorted_items = sorted(victimas_por_entidad.items(), key=lambda x: x[1], reverse=True)
    entidades = [item[0] for item in sorted_items]
    valores = [item[1] for item in sorted_items]
    max_valor = max(valores)
    total = sum(valores)

   
    y_positions = np.arange(len(entidades)) 

    
    fig, ax = plt.subplots(figsize=(10, 14), dpi=300)
    fig.patch.set_facecolor('white')
    ax.set_facecolor('white')

    x_max = max_valor * 1.5
    x_interval = max_valor // 5 or 1

    # Líneas verticales
    x_ticks = np.arange(0, x_max + x_interval, x_interval)
    for x in x_ticks:
        lw = 2 if x == max_valor else 0.75
        lc = 'black' if x == max_valor else '#B9B9B9'
        ax.axvline(x, color=lc, linewidth=lw)

    # Dibujar barras
    for y_pos, entidad, valor in zip(y_positions, entidades, valores):
        porcentaje = round((valor / total) * 100, 1)

        if valor == max_valor:
            for alpha in np.linspace(0.3, 1, 10):
                ax.barh(y_pos, valor, height=bar_height,
                        color='#8B0000', alpha=alpha, edgecolor='none', zorder=2)
            bbox_color = '#8B0000'
            text_color = font_config['capsula_max']['color']
            edge_col = 'none'
            lw = 0
        else:
            for alpha in np.linspace(0.1, 0.8, 10):
                ax.barh(y_pos, valor, height=bar_height,
                        color='#10302C', alpha=alpha, edgecolor='none', zorder=2)
            bbox_color = 'white'
            text_color = font_config['capsula_valor']['color']
            edge_col = '#002F2A'
            lw = 1.5

        # Cápsula con valor
        ax.text(
            total_valor + offset_capsula, y_pos, f"{valor:,}",
            bbox=dict(boxstyle="round,pad=0.3,rounding_size=0.7",
                          facecolor=bbox_color,
                          edgecolor=edge_col,
                          linewidth=lw),
            ha='left',
            va='center',
            fontsize=font_config['capsula_valor']['size'],
            fontfamily=font_config['family'],
            fontweight=font_config['capsula_valor']['weight'],
            color=text_color
        )

        # Porcentaje
        ax.text(
            total_valor + offset_porcentaje, y_pos, f"{porcentaje}%",
            color=font_config['porcentaje']['color'],
            fontsize=font_config['porcentaje']['size'],
            fontfamily=font_config['family'],
            fontweight=font_config['porcentaje']['weight'],
            ha='left',
            va='center'
        )

    # Eje Y (etiquetas)
    ax.set_yticks(y_positions)
    ax.set_yticklabels(
        entidades,
        fontsize=font_config['eje_y']['size'],
        fontfamily=font_config['family'],
        fontweight=font_config['eje_y']['weight']
    )

    ax.set_xlim(0, x_max)
    ax.invert_yaxis()

    for spine in ax.spines.values():
        spine.set_visible(False)
    ax.tick_params(
        axis='x',
        labelsize=font_config['eje_x']['size'],  # Tamaño de la fuente
        labelcolor=font_config['eje_x']['color']  # Color de la fuente
    )
    ax.grid(False)

    plt.tight_layout()

    # Guardar la gráfica como archivo SVG
    plt.savefig("barras_horizontales.svg", format="svg", bbox_inches='tight')
    plt.show()

barras_horizontales(dataframe_a_graficar)
</code></pre>
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/barras%20horizontales" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
</div>

 <div class="flex-container">
    <div class="code-card">
      <div class="code-header">Barras verticales</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/barras verticales/barras_verticales.svg">
    </div>
<pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import font_manager
from pathlib import Path

# VARIABLES A CAMBIAR:
dataframe_a_graficar = victimas_por_entidad

# Configurar las fuentes SVG como texto editable
plt.rcParams['svg.fonttype'] = 'none'

# Ruta relativa para las fuentes
font_dirs = [Path("fonts/arial")]
font_files = font_manager.findSystemFonts(fontpaths=font_dirs)

for font_file in font_files:
    font_manager.fontManager.addfont(font_file)

# Crear una instancia de FontProperties para Arial
arial_font = font_manager.FontProperties(fname=str(font_files[0]))


def calcular_intervalo(max_valor):
    """Calcula un intervalo adecuado para el eje Y basado en el valor máximo"""
    potencia = 10 ** (int(np.log10(max_valor)) - 1)
    intervalo = round(max_valor / 5 / potencia) * potencia

    # Asegurar que el intervalo no sea muy pequeño o grande
    if max_valor / intervalo > 8:
        intervalo *= 2
    elif max_valor / intervalo < 4:
        intervalo /= 2

    return max(intervalo, 1)  # Mínimo intervalo de 1

def barras_verticales(victimas_por_entidad, bar_width=0.6):
    font_config = {
        'family': 'Arial',  # Cambiar a Arial
        'titulo': {'size': 36, 'weight': 'medium', 'color': '#000000'},
        'eje_y': {'size': 12, 'weight': 'medium', 'color': '#000000'},
        'eje_x': {'size': 12, 'weight': 'medium', 'color': '#000000'},
        'etiquetas_eje_y': {'size': 24, 'weight': 'medium', 'color': '#767676'},
        'etiquetas_eje_x': {'size': 24, 'weight': 'semibold', 'color': '#767676'},
        'capsula_valor': {'size': 12, 'weight': 'medium', 'color': '#10302C'},
        'capsula_max': {'size': 12, 'weight': 'medium', 'color': 'white'},
        'porcentaje': {'size': 14, 'weight': 'medium', 'color': '#4C6A67'},
        'leyenda': {'size': 20, 'weight': 'medium', 'color': '#767676'}  # Nueva categoría para la leyenda
    }

    categorias = ['Hombre', 'Mujer', 'No identificado']
    data['Total'] = data[categorias].sum(axis=1)
    sorted_data = data.sort_values(by='Total', ascending=False)
    entidades = sorted_data.index.tolist()

    max_valor = sorted_data['Total'].max()
    total = sorted_data['Total'].sum()

    y_max = max_valor * 1.15
    y_interval = calcular_intervalo(max_valor)

    fig, ax = plt.subplots(figsize=(16, 6), dpi=300)
    fig.patch.set_facecolor('white')
    ax.set_facecolor('white')

    y_ticks = np.arange(0, y_max + y_interval, y_interval)
    for y in y_ticks:
        lw = 2 if y == y_max else 0.75
        lc = 'black' if y == y_max else '#B9B9B9'
        ax.axhline(y, color=lc, linewidth=lw)

    ax.axhline(0, color='black', linewidth=2, zorder=1)

    offset_capsula = y_max * 0.05  
    offset_porcentaje = y_max * 0.15 
    bar_positions = np.arange(len(entidades))

    colores = {
        'Hombre': '#4C6A67',
        'Mujer': '#627B78',
        'No identificado': '#6F8583'
    }
    categorias = list(colores.keys());

    for i, entidad in enumerate(entidades):
        row = sorted_data.loc[entidad]
        x_pos = bar_positions[i]
        y_bottom = 0

        for cat in categorias:
            valor = row[cat]
            ax.bar(x_pos, valor, width=bar_width, bottom=y_bottom,
                   color=colores[cat], edgecolor='none', zorder=2)
            y_bottom += valor

        total_valor = row['Total']
        porcentaje = round((total_valor / total) * 100, 1)

        # Estilo de texto
        texto_kwargs = dict(
            ha='center',
            va='bottom',
            fontsize=font_config['capsula_valor']['size'],
            fontfamily=font_config['family'],
            fontweight=font_config['capsula_valor']['weight'],
            color=font_config['capsula_valor']['color']
        )

        # Ajuste de estilo de cápsula según el valor
        if total_valor <= 5:
            boxstyle = "round,pad=0.4,rounding_size=0.59"
        elif total_valor <= 50:
            boxstyle = "round,pad=0.3,rounding_size=0.7"
        elif total_valor <= 100:
            boxstyle = "round,pad=0.3,rounding_size=0.79"
        else:
            boxstyle = "round,pad=0.3,rounding_size=0.9"

        bbox_props = dict(
            boxstyle=boxstyle,
            facecolor='white',
            edgecolor='#002F2A',
            linewidth=1.5
        )

        # Cápsula con total
        ax.text(
            x_pos, total_valor + offset_capsula, f"{int(total_valor):,}",
            bbox=bbox_props,
            **texto_kwargs
        )

        # Porcentaje encima
        ax.text(
            x_pos, total_valor + offset_porcentaje, f"{porcentaje}%",
            color=font_config['porcentaje']['color'],
            fontsize=font_config['porcentaje']['size'],
            fontfamily=font_config['family'],
            fontweight=font_config['porcentaje']['weight'],
            ha='center',
            va='bottom'
        )

    # Eje X
    ax.set_xticks(bar_positions)
    ax.set_xticklabels(
        entidades, rotation=90,
        fontsize=font_config['eje_x']['size'],
        fontfamily=font_config['family'],
        fontweight=font_config['eje_x']['weight']
    )

    ax.set_ylim(0, y_max)
    ax.set_xlim(bar_positions[0] - bar_width, bar_positions[-1] + bar_width)

    # Limpiar bordes y ticks
    for spine in ax.spines.values():
        spine.set_visible(False)
    ax.tick_params(axis='both', which='both', length=0)
    ax.grid(False)

    plt.tight_layout()

    # Guardar la gráfica como archivo SVG
    plt.savefig("barras_verticales.svg", format="svg", bbox_inches='tight')
    plt.show()

barras_verticales(dataframe_a_graficar)
</code></pre>
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/barras%20verticales" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
</div>

 <div class="flex-container">
    <div class="code-card">
      <div class="code-header">Gráfica de línea</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/linea/linea.svg">
    </div>
<pre><code class="language-python">
from pathlib import Path
import matplotlib.transforms as mtrans
from matplotlib.text import TextPath
from matplotlib.patches import PathPatch
import matplotlib.pyplot as plt
from matplotlib.dates import date2num
import matplotlib.font_manager as font_manager

# VARIABLES A CAMBIAR
dataframe_a_graficar = df

# Configurar las fuentes SVG como texto editable
plt.rcParams['svg.fonttype'] = 'none'

# Ruta relativa para las fuentes
font_dirs = [Path("fonts/arial")]
font_files = font_manager.findSystemFonts(fontpaths=font_dirs)

for font_file in font_files:
    font_manager.fontManager.addfont(font_file)

# Crear una instancia de FontProperties para Arial
arial_font = font_manager.FontProperties(fname=str(font_files[0]))


def curly_at_fechas(x, y, width, height, ax=None, color="k"):
    """
    Dibuja una llave '{' o '}' en cualquier lugar del gráfico.

    Parámetros:
    - x: Coordenada X (puede ser una fecha o un valor numérico).
    - y: Coordenada Y.
    - width: Ancho de la llave.
    - height: Altura de la llave.
    - ax: Eje de Matplotlib donde se dibujará la llave (opcional).
    - color: Color del símbolo de la llave (por defecto es negro).
    """
    if not ax:
        ax = plt.gca()
    
    # Si x es una fecha, convertirla a un valor numérico
    if isinstance(x, pd.Timestamp):
        x = date2num(x)
    
    # Crear el símbolo de la llave con una fuente explícita
    tp = TextPath((0, 0), "}", size=1, prop=dict(family="DejaVu Sans"))
    
    # Escalar y trasladar la llave
    trans = (
        mtrans.Affine2D().scale(width, height) +
        mtrans.Affine2D().translate(x, y) +
        ax.transData
    )
    
    # Crear y añadir el PathPatch al eje con el color especificado
    pp = PathPatch(tp, lw=0, fc=color, transform=trans)
    ax.add_artist(pp)


def lineal(df, columna_fecha, columna_grafica, columna_linea, tipografia=None):
    """Genera una gráfica de área (area plot) para una columna específica de un DataFrame."""
    # Verificar que las columnas especificadas existan en el DataFrame
    if columna_fecha not in df.columns:
        raise ValueError(f"La columna '{columna_fecha}' no existe en el DataFrame.")
    if columna_grafica not in df.columns:
        raise ValueError(f"La columna '{columna_grafica}' no existe en el DataFrame.")
    if columna_linea not in df.columns:
        raise ValueError(f"La columna '{columna_linea}' no existe en el DataFrame.")
    
    font_config = {
        'family': 'Arial',  # Cambiar a Arial
        'titulo': {'size': 36, 'weight': 'medium', 'color': '#000000'},
        'eje_y': {'size': 24, 'weight': 'medium', 'color': '#000000'},
        'eje_x': {'size': 24, 'weight': 'medium', 'color': '#000000'},
        'etiquetas_eje_y': {'size': 24, 'weight': 'medium', 'color': '#767676'},
        'etiquetas_eje_x': {'size': 24, 'weight': 'semibold', 'color': '#767676'},
        'capsula_valor': {'size': 9, 'weight': 'medium', 'color': '#10302C'},
        'capsula_max': {'size': 18, 'weight': 'medium', 'color': 'white'},
        'porcentaje': {'size': 10, 'weight': 'medium', 'color': '#4C6A67'},
        'leyenda': {'size': 20, 'weight': 'medium', 'color': '#767676'}  # Nueva categoría para la leyenda
    }
    
    # Configurar el tamaño de la figura en píxeles
    ancho_px = 1480
    alto_px = 520
    dpi = 100  # Resolución en píxeles por pulgada
    ancho_in = ancho_px / dpi
    alto_in = alto_px / dpi
    
    # Crear la figura con el tamaño especificado
    fig, ax = plt.subplots(figsize=(ancho_in, alto_in), dpi=dpi)
    
    # Seleccionar colores específicos
    color_area = '#d4dce9'  # Primer color de la lista
    color_linea = '#2f5597'  # Segundo color de la lista
    color_linea_punteada = '#c00000'  # Color para la línea punteada
    
    # Graficar el área
    ax.fill_between(
        df[columna_fecha],
        df[columna_grafica],
        color=color_area,  # Color del área
        alpha=1.,
    )
    
    # Graficar la línea sobre el área
    ax.plot(
        df[columna_fecha],
        df[columna_grafica],
        color=color_linea,  # Color de la línea
        linewidth=2
    )
    
    # Graficar la línea punteada
    ax.plot(
        df[columna_fecha],
        df[columna_linea],
        color=color_linea_punteada,  # Color de la línea punteada
        linestyle='--',  # Estilo de línea punteada
        linewidth=2
    )
    
    # Configurar etiquetas y título
    ax.set_xlabel(columna_fecha, fontdict=font_config['eje_x'])
    ax.set_ylabel("Valores", fontdict=font_config['eje_y'])

    # Configurar las etiquetas del eje X
    ax.tick_params(axis='x', labelsize=font_config['etiquetas_eje_x']['size'], labelcolor=font_config['etiquetas_eje_x']['color'])
    ax.tick_params(axis='y', labelsize=font_config['etiquetas_eje_y']['size'], labelcolor=font_config['etiquetas_eje_y']['color'])

    # Posicionar el eje X en y=0
    ax.spines['bottom'].set_position(('data', 0))

    # Rotar las etiquetas del eje X
    plt.xticks(rotation=90)
    
    # Desactivar o activar bordes
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['bottom'].set_visible(True)
    
    # Asignar grosor a los ejes visibles
    ax.spines['bottom'].set_linewidth(2)  # Grosor del eje inferior
    
    # Mantener las líneas del grid
    ax.grid(axis='y', linestyle='-', color='#000000', alpha=0.2, linewidth=0.75)
    ax.grid(axis='x', linestyle='-', color='#000000', alpha=0.2, linewidth=0.75)
    
    # Convertir la fecha 2024 a un índice o posición en el eje X
    x_pos = df["Fecha"].iloc[-1]
    y_pos_gra = df[columna_grafica].iloc[-1]
    y_pos_lin = df[columna_linea].iloc[-1]
    if y_pos_gra > y_pos_lin:
        y_pos_min = y_pos_lin
        y_pos_max = y_pos_gra
    else:   
        y_pos_min = y_pos_gra
        y_pos_max = y_pos_lin
    altura = y_pos_max - y_pos_min

    # Calcular los factores proporcionales
    x_min, x_max = ax.get_xlim()  # Obtener los límites del eje X
    y_min, y_max = ax.get_ylim()  # Obtener los límites del eje Y

    factor_ancho = 0.04 * (x_max - x_min)  # Proporcional al rango del eje X
    factor_alto = 0.05 * (y_max - y_min)   # Proporcional al rango del eje Y

    # Añadir el símbolo de la llave
    curly_at_fechas(x_pos, y_pos_min+0.2*factor_alto, width=factor_ancho, height=altura+factor_alto, ax=ax, color="#af0b19")
    
    # Calcular la diferencia entre y_pos_gra y y_pos_lin
    diferencia = round(y_pos_gra - y_pos_lin)

    # Añadir una cápsula con la diferencia en la parte derecha de la gráfica
    color_capsula = "#af0b19"  # Color de la cápsula
    bbox_props = dict(boxstyle="round,pad=0.25,rounding_size=0.99", fc=color_capsula, ec="none", alpha=1.0)

    x_pos_numeric = date2num(x_pos)  # Convertir la fecha a un número

    # Posicionar la cápsula en la parte derecha de la gráfica
    ax.text(
        x_pos_numeric + 1.8 * factor_ancho,  # Usar el valor numérico de x_pos
        y_pos_min + altura / 2.5,  # Centrar verticalmente entre y_pos_gra y y_pos_lin
        diferencia,  # Texto de la cápsula
        color="white",  # Color del texto
        fontsize=font_config['capsula_max']['size'],  # Tamaño de la fuente
        bbox=bbox_props,  # Estilo de la cápsula
        ha="center",  # Alinear horizontalmente
        va="center"   # Alinear verticalmente
    )
    
    # Guardar la gráfica como archivo SVG
    plt.savefig("linea.svg", format="svg", bbox_inches='tight', dpi=dpi)
    plt.show()

# Ejemplo de uso
lineal(dataframe_a_graficar, columna_fecha="Fecha", columna_grafica="Columna1", columna_linea="Columna3")
</code></pre>
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/linea" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
</div>

 <div class="flex-container">
    <div class="code-card">
      <div class="code-header">Areaplot con snapshot</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/snapshot/snapshot.svg">
    </div>
<pre><code class="language-python">
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import font_manager
from scipy.interpolate import make_interp_spline

# VARIABLES A CAMBIAR:
dataframe_a_graficar = data

# Configurar las fuentes SVG como texto editable
plt.rcParams['svg.fonttype'] = 'none'

# Ruta relativa para las fuentes
font_dirs = [Path("fonts/arial")]
font_files = font_manager.findSystemFonts(fontpaths=font_dirs)

for font_file in font_files:
    font_manager.fontManager.addfont(font_file)

# Crear una instancia de FontProperties para Arial
arial_font = font_manager.FontProperties(fname=str(font_files[0]))

def snapshot(data):
    """
    Genera un gráfico de área apilada con los datos proporcionados en un DataFrame.

    Parámetros:
    - data: DataFrame que contiene las columnas 'fechas', 'comisiones', 'fiscalias' y 'portal'.
    """
    font_config = {
        'family': 'Arial',  # Cambiar a Arial
        'titulo': {'size': 36, 'weight': 'medium', 'color': '#000000'},
        'eje_y': {'size': 24, 'weight': 'medium', 'color': '#000000'},
        'eje_x': {'size': 24, 'weight': 'medium', 'color': '#000000'},
        'etiquetas_eje_y': {'size': 24, 'weight': 'medium', 'color': '#767676'},
        'etiquetas_eje_x': {'size': 24, 'weight': 'semibold', 'color': '#767676'},
        'capsula_valor': {'size': 20, 'weight': 'medium', 'color': '#10302C'},
        'capsula_max': {'size':  12, 'weight': 'medium', 'color': 'white'},
        'porcentaje': {'size': 20, 'weight': 'medium', 'color': 'white'},
        'leyenda': {'size': 30, 'weight': 'medium', 'color': '#767676'}  # Nueva categoría para la leyenda
    }

    # Extraer columnas del DataFrame
    fechas = data['fechas']
    comisiones = data['comisiones']
    fiscalias = data['fiscalias']
    portal = data['portal']
    
    # Crear figura
    fig, ax = plt.subplots(figsize=(16, 8))
    n = len(fechas)
    x = np.arange(n) + 0.5  # Desfase visual

    fig_sub = plt.figure(figsize=(16, 8))
    gs = fig.add_gridspec(1, 2, width_ratios=[3, 1], height_ratios=[1])

    # ==============================================
    # 2.1. PRIMER SUBPLOT - GRÁFICO DE ÁREAS
    # ==============================================
    ax1 = fig_sub.add_subplot(gs[0])  # Usa este, no crees otra figura

    # Suavizar las curvas visualmente
    x_suave = np.linspace(x.min(), x.max(), 300)  # Más puntos para suavizar
    comisiones_suave = make_interp_spline(x, comisiones)(x_suave)
    fiscalias_suave = make_interp_spline(x, fiscalias)(x_suave)
    portal_suave = make_interp_spline(x, portal)(x_suave)


    x = np.arange(n) + 0.5
    ax1.stackplot(x_suave, comisiones_suave, fiscalias_suave, portal_suave, labels=[
        'Comisiones', 'Fiscalías y Procuradurías', 'Portal'],
        colors=['#215F53', '#7570B3', '#C7EAE5'])

    # Eje X
    ax1.set_xticks(x)
    ax1.set_xticklabels(fechas, rotation=90, fontsize=font_config['etiquetas_eje_x']['size'], 
                         fontweight=font_config['etiquetas_eje_x']['weight'], 
                         color=font_config['etiquetas_eje_x']['color'])
    ax1.set_xlim(x[0] - 0.5, x[-1] + 0.5)

    # Eje Y
    ax1.set_yticks(np.linspace(0, 1, 5))
    ax1.set_yticklabels(['0%', '25%', '50%', '75%', '100%'], fontsize=font_config['etiquetas_eje_y']['size'], 
                         fontweight=font_config['etiquetas_eje_y']['weight'], 
                         color=font_config['etiquetas_eje_y']['color'])

    # Estética
    ax1.spines['top'].set_visible(False)
    ax1.spines['right'].set_visible(False)
    ax1.spines['left'].set_visible(False)
    ax1.spines['bottom'].set_linewidth(2)
    ax1.grid(axis='y', linestyle='-', color='white', alpha=0.8, linewidth=1.25)
    ax1.grid(axis='x', linestyle='-', color='white', alpha=0.3, linewidth=0.75)

    # Etiquetas de totales
    x_coords = [1.5, 6, 10.5]
    y_coords = [0.15, 0.45, 0.85]
    totales = [sum(comisiones), sum(fiscalias), sum(portal)]
    colores_borde = ['#D9D9D9'] * 3

    for x_c, y_c, total, color_borde in zip(x_coords, y_coords, totales, colores_borde):
        ax1.text(x_c, y_c, f"{total:.2f}",
                 ha='center', va='center',
                 fontsize=font_config['capsula_valor']['size'], 
                 color=font_config['capsula_valor']['color'],
                 bbox=dict(boxstyle="round,pad=0.6,rounding_size=1",
                           facecolor='white', edgecolor=color_borde, linewidth=1.8))

    # ==============================================
    # 2.2. SEGUNDO SUBPLOT - Snapshot
    # ==============================================
    ax2 = fig_sub.add_subplot(gs[1])

    # Datos simulados (sept. 2006)
    totales = np.array([sum(comisiones[:1]), sum(fiscalias[:1]), sum(portal[:1])])
    totales_norm = totales / totales.sum()

    colores = ['#215F53', '#7570B3', '#C7EAE5']
    bar_width = 0.5

    # Dibujar barra apilada
    bottom = 0
    for i, (valor, color) in enumerate(zip(totales_norm, colores)):
        ax2.bar(0, valor, width=bar_width, bottom=bottom,
                color=color, edgecolor='white', linewidth=0.5)
    
        # Etiqueta de porcentaje en el centro
        ax2.text(0, bottom + valor/2, f"{valor*100:.1f}%",
                 ha='center', va='center', color=font_config['porcentaje']['color'], 
                 fontweight=font_config['porcentaje']['weight'], 
                 fontsize=font_config['porcentaje']['size'])
        bottom += valor

    # Estética limpia
    ax2.set_xlim(-0.5, 0.5)
    ax2.set_ylim(0, 1)
    ax2.set_xticks([])
    ax2.set_yticks([])

    for spine in ax2.spines.values():
        spine.set_visible(False)
    
    # Eliminar etiquetas de fecha del segundo subplot
    ax2.tick_params(bottom=False, labelbottom=False)

    # Evitar espacio excesivo
    plt.subplots_adjust(wspace=0.05, hspace=0.05)

    # Crear una instancia de FontProperties para la leyenda
    leyenda_font = font_manager.FontProperties(
        family=font_config['family'],
        size=font_config['leyenda']['size'],
        weight=font_config['leyenda']['weight']
    )

    # Leyenda común
    fig_sub.legend(
        ['Comisiones', 'Fiscalías', 'Portal'],
        loc='upper center',
        ncol=3,
        frameon=False,
        fontsize=font_config['leyenda']['size'],
        prop=leyenda_font,  # Usar la instancia de FontProperties
        bbox_to_anchor=(0.5, 1.05)  # Ajustar la posición vertical (1.05 es un poco más arriba)
    )    

    plt.tight_layout()

    # Guardar la gráfica como archivo SVG
    plt.savefig("snapshot.svg", format="svg", bbox_inches='tight')
    plt.show()

snapshot(dataframe_a_graficar)
</code></pre>
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/snapshot" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
</div>

 <div class="flex-container">
    <div class="code-card">
      <div class="code-header">Treemap</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/treemap/treemap.svg">
    </div>
<pre><code class="language-python">
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import font_manager
import squarify 

# VARIABLES A CAMBIAR:
dataframe_a_graficar = victimas_por_entidad

# Configurar las fuentes SVG como texto editable
plt.rcParams['svg.fonttype'] = 'none'

# Ruta relativa para las fuentes
font_dirs = [Path("fonts/arial")]
font_files = font_manager.findSystemFonts(fontpaths=font_dirs)

for font_file in font_files:
    font_manager.addfont(font_file)

# Crear una instancia de FontProperties para Arial
arial_font = font_manager.FontProperties(fname=str(font_files[0]))


def treemap(victimas_por_entidad):
    if not isinstance(victimas_por_entidad, pd.Series):
        raise ValueError("Los datos deben ser una Serie de pandas")

    # Asegurar que todos los valores sean numéricos tipo float
    victimas_por_entidad = pd.to_numeric(victimas_por_entidad, errors='coerce').fillna(0).astype(float)

    # Configuración de fuentes y colores
    font_config = {
        'family': 'Arial',
        'titulo': {'size': 18, 'weight': 'bold', 'color': '#10302C'},
        'etiquetas': {'size': 10, 'weight': 'bold', 'color': 'white'},
        'porcentaje': {'size': 9, 'weight': 'medium', 'color': '#A57F2C'}
    }

    try:
        # Crear dataframe desde la serie
        df = pd.DataFrame({
            'ENTIDAD': victimas_por_entidad.index,
            'Total': victimas_por_entidad.values
        })
        df.set_index('ENTIDAD', inplace=True)

        # Ordenar y calcular porcentaje
        df = df.sort_values(by='Total', ascending=False)
        total_nacional = df['Total'].sum()
        df['Porcentaje'] = (df['Total'] / total_nacional * 100).round(1)
    except Exception as e:
        print(f"Error: {e}")
        return None

    # Colores
    max_valor = df['Total'].max()
    colores = ['#10302C' if val == max_valor else '#4C6A67' for val in df['Total']]

    # Configurar la figura
    plt.rc('font', family=font_config['family'])
    fig, ax = plt.subplots(figsize=(16, 10), dpi=300)
    fig.patch.set_facecolor('white')
    ax.set_facecolor('white')

    # rectangulos
    sizes = df['Total'].tolist()
    rectangles = squarify.normalize_sizes(sizes, 1, 1)
    rectangles = squarify.squarify(rectangles, 0, 0, 1, 1)

    for rect, (entidad, row), color in zip(rectangles, df.iterrows(), colores):
        x, y, dx, dy = rect['x'], rect['y'], rect['dx'], rect['dy']

        ax.add_patch(plt.Rectangle(
            (x, y), dx, dy,
            facecolor=color,
            edgecolor='white',
            linewidth=5
        ))

        area = dx * dy

        if area > 0.001:
            palabras = entidad.split()
            if len(palabras) > 2:
                entidad_mod = ' '.join(palabras[:2]) + '\n' + ' '.join(palabras[2:])
            else:
                entidad_mod = entidad

            etiqueta = f"{entidad_mod}\n{int(row['Total']):,}\n{row['Porcentaje']}%"

            # Ajuste automático de tamaño de fuente según área
            if area > 0.02:
                fontsize = 10
            elif area > 0.01:
                fontsize = 8
            else:
                fontsize = 6

            x_text = x + dx * 0.04
            y_text = y + dy * 0.88

            ax.text(
                x_text,
                y_text,
                etiqueta,
                ha='left',
                va='top',
                fontsize=fontsize,
                fontweight=font_config['etiquetas']['weight'],
                color=font_config['etiquetas']['color'],
                zorder=10
            )

    ax.axis('off')

    plt.tight_layout()

    # Guardar la gráfica como archivo SVG
    plt.savefig("treemap.svg", format="svg", bbox_inches='tight')
    plt.show()

treemap(dataframe_a_graficar)
</code></pre>
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/treemap" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
</div>

 <div class="flex-container">
    <div class="code-card">
      <div class="code-header">Barras de tendencia</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/grafica_barras_tendencias/CDMX_grafica_barras_tendencias.svg">
    </div>
<pre><code class="language-python">
# Crear una gráfica por estado
for estado in estados:
    fig, ax = plt.subplots(figsize=(12, 6))
    df_estado = df[df['estado'] == estado]
    pivot_df = df_estado.pivot(index='fecha', columns='indicador', values='valor').fillna(0)
    pivot_df[['Con datos', 'Sin datos']].plot(kind='bar', stacked=True, color=["#584290", "#b1adcf"], ax=ax, width=1)

    ax.set_title(f'{estado} - Casos con y sin datos', fontsize=14, fontweight='bold')
    ax.set_xlabel('Fecha')
    ax.set_ylabel('Número de casos')
    ax.set_xticks(range(0, len(pivot_df), 12))
    ax.set_xticklabels([date.strftime('%Y') for date in pivot_df.index[::12]], rotation=45, fontsize=8)
    ax.legend(title='')
    ax.grid(False)
    plt.tight_layout()
    plt.show()

    file_base = os.path.join(output_dir, f"{estado.replace(' ', '_')}_grafica_barras_tendencias")
    fig.savefig(f"{file_base}.png", format="png", bbox_inches='tight', dpi=300)
    fig.savefig(f"{file_base}.svg", format="svg", bbox_inches='tight', dpi=300)
    plt.close(fig)
</code></pre>
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/grafica_barras_tendencias" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
</div>


 <div class="flex-container">
    <div class="code-card">
      <div class="code-header">Barra previa</div>
      <div class="code-content">
      <div class="svg-container">
        <img src="Python/barras apiladas/apiladas_original_svgo.svg">
    </div>
<!-- INICIO_CODIGO:barras_apiladas -->

<!-- FIN_CODIGO:barras_apiladas -->

<!-- INICIO_CODIGO:barra_previa -->
<pre><code class="language-python">
# EXPORTAR: barra_previa

barras_apiladas(df1f, 
                nombre="barra_previa", 
                bar_height=0.9, 
                font='Montserrat',
                fontsize_valor_total=30,
                ordenar_por='etiqueta',
                orden='ascendente',
                valor_barra=False, 
                porcentaje_barra=False,
                porcentaje_total=False,
                orientacion='vertical',
                quitar_capsula=True,
                agregar_datos=[(pd.Timestamp(2005, 1, 1), "Previo", (192, 313, "38%"))],
                asignar_etiquetas='porcentaje',
                grillas=False,
                paleta_colores=["#10302C", "#E6E6E6"]
                )
</code></pre>
<!-- FIN_CODIGO:barra_previa -->
      <a class="btn" href="https://github.com/tabonitaa/graficas_gob/tree/main/Python/barras_apiladas" target="_blank">
        Ver carpeta en GitHub
      </a>
    </div>
  </div>
</div>


</div>
<script>
  const menuToggle = document.querySelector('.menu-toggle');
  const menuDropdown = document.getElementById('menuDropdown');

  menuToggle.addEventListener('click', function() {
    menuDropdown.style.display = menuDropdown.style.display === 'flex' ? 'none' : 'flex';
  });

  // Opcional: cerrar el menú al hacer clic fuera
  document.addEventListener('click', function(event) {
    if (!menuDropdown.contains(event.target) && !menuToggle.contains(event.target)) {
      menuDropdown.style.display = 'none';
    }
  });
</script>
</body>
</html>

